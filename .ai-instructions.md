# AI Development Instructions for terraform-provider-gopass

## Critical Project Requirements

### Test Coverage Policy

**MANDATORY REQUIREMENT: This project maintains 100% test coverage.**

1. **Never Complete a Task Without Tests**
   - Every code change MUST be accompanied by corresponding tests
   - A task is NEVER considered complete if test coverage falls below 100%
   - All new functions, methods, and code paths MUST have unit tests

2. **Test-First Development**
   - When adding new features, write tests FIRST that demonstrate the desired behavior
   - Tests should initially fail, then pass after implementation
   - This ensures tests actually validate the feature

3. **Refactoring Requirements**
   - Before refactoring: Run tests to establish baseline (`go test ./...`)
   - During refactoring: Maintain or improve test coverage
   - After refactoring: Verify all tests pass AND coverage remains 100%
   - Add tests for any previously uncovered edge cases discovered during refactoring

4. **Verification Steps**
   - Always run `go test ./...` before considering a task complete
   - Check test coverage with `go test -cover ./...`
   - Aim for 100% coverage in all packages
   - If coverage drops below 100%, add tests until it's restored

### Testing Standards

#### Unit Test Requirements

1. **Coverage Scope**
   - Test all public functions and methods
   - Test all exported types and interfaces
   - Test error paths and edge cases
   - Test boundary conditions

2. **Test Organization**
   - Use table-driven tests for multiple scenarios
   - Group related tests with descriptive subtest names
   - Keep tests isolated and independent
   - Use mocks/stubs for external dependencies

3. **Test Naming**
   - Function tests: `Test<FunctionName>_<Scenario>`
   - Example: `TestGetSecret_NotFound`, `TestGetSecret_Success`
   - Use descriptive scenario names that explain what's being tested

4. **Error Testing**
   - Every error return path MUST be tested
   - Test error wrapping and error messages
   - Verify diagnostics and user-facing error messages

#### Integration Test Guidelines

1. **Acceptance Tests**
   - Mark with `TF_ACC=1` environment variable requirement
   - Document prerequisites (e.g., gopass setup, GPG keys)
   - Provide clear setup instructions in test documentation

2. **Example Validation**
   - All examples in `examples/` should be tested
   - Examples should demonstrate real-world usage
   - Include comments explaining the example's purpose

### Code Quality Standards

1. **Documentation**
   - All exported functions MUST have doc comments
   - Doc comments should explain what, why, and any gotchas
   - Complex algorithms should have implementation comments

2. **Error Handling**
   - Always wrap errors with context: `fmt.Errorf("operation failed: %w", err)`
   - Provide actionable error messages for users
   - Never ignore errors without explicit justification

3. **Terraform Provider Standards**
   - Follow HashiCorp's provider development guidelines
   - Use proper schema definitions with descriptions
   - Maintain backward compatibility unless major version bump
   - Validate all user inputs

4. **Defensive Code and Dead Code Policy**
   - **AVOID overly defensive code** that cannot be tested or is unreachable
   - Do NOT add nil checks for variables that are guaranteed to be initialized
   - Do NOT add error handling for conditions that cannot occur
   - **It is MANDATORY to remove dead code** - code that cannot be executed
   - **It is OK to remove overly defensive code** to achieve 100% coverage
   - One objective of 100% test coverage is to **identify and eliminate**:
     - Dead code (unreachable statements)
     - Overly defensive checks (unnecessary nil checks, impossible error conditions)
     - Redundant safety checks
   - If you cannot write a test that reaches a code path, that code is either:
     - Dead code (should be removed)
     - Overly defensive (should be removed)
     - Actually reachable but test is missing (add the test)
   - **Prefer simple, testable code over complex defensive code**

### Workflow for Code Changes

```
1. ✅ Understand the requirement
2. ✅ Write failing tests that demonstrate desired behavior
3. ✅ Implement the feature/fix
4. ✅ Run tests: `go test ./...` - must pass
5. ✅ Check coverage: `go test -cover ./...` - must be 100%
6. ✅ Run linter: `make lint` - must pass
7. ✅ Update documentation (README, examples, code comments)
8. ✅ Verify all examples still work
9. ✅ Final test run to confirm everything passes
10. ✅ ONLY THEN consider the task complete
```

### Pre-Completion Checklist

Before marking ANY task as complete, verify:

- [ ] All tests pass: `go test ./...` returns PASS
- [ ] Test coverage is 100%: `go test -cover ./...`
- [ ] Linter passes: `make lint` or `golangci-lint run ./...`
- [ ] All new code has corresponding tests
- [ ] All error paths are tested
- [ ] Documentation is updated (code comments, README, examples)
- [ ] Examples are syntactically correct and tested
- [ ] No backwards compatibility broken (unless intentional major version)
- [ ] Changes follow Terraform provider best practices

### Failure Conditions

A task is **NOT COMPLETE** if:

- ❌ Any test fails
- ❌ Test coverage drops below 100%
- ❌ Linter reports errors
- ❌ New code lacks tests
- ❌ Error paths are not tested
- ❌ Documentation is missing or outdated
- ❌ Breaking changes without version bump justification

### Project-Specific Context

#### Technology Stack
- Language: Go 1.21+
- Framework: terraform-plugin-framework
- Testing: Go standard testing + mock gopass store
- Dependencies: gopass library, Terraform plugin SDK

#### Key Components
1. **GopassClient** (`internal/provider/gopass_client.go`)
   - Wrapper around gopass library
   - All methods must have error tests
   - Mock store used for testing

2. **Ephemeral Resources** (`internal/provider/*_ephemeral.go`)
   - gopass_secret: Single secret retrieval
   - gopass_env: Recursive secret tree with nested object support
   - Must never store secrets in state

3. **Managed Resources** (`internal/provider/secret_resource.go`)
   - Write-only secret storage
   - Drift detection via revision counting
   - Delete behavior configurable

#### Testing Helpers
- `mockStore` in `gopass_client_test.go`: Mock implementation of gopass.Store
- Use `tfsdk.Config` and `tftypes.Value` for framework testing
- Mock failures with `shouldFail` flag in test stores

### Security Considerations

1. **Secrets Handling**
   - Never log secret values (only paths)
   - Ensure ephemeral values never reach state
   - Test that sensitive values are marked as sensitive

2. **Error Messages**
   - Don't expose secret values in error messages
   - Provide helpful troubleshooting without security leaks

### References

- [Terraform Plugin Framework](https://developer.hashicorp.com/terraform/plugin/framework)
- [Go Testing Best Practices](https://go.dev/doc/tutorial/add-a-test)
- [gopass API Documentation](https://github.com/gopasspw/gopass)

---

**Remember: 100% test coverage is not optional. It's a requirement for this project.**

If you encounter a situation where achieving 100% coverage seems difficult:
1. Break down the code into smaller, testable units
2. Use dependency injection for external dependencies
3. Create appropriate mocks/stubs
4. Test both success and failure paths
5. Use table-driven tests for multiple scenarios

**A task is complete ONLY when all tests pass AND coverage is 100%.**
